import dotenv from 'dotenv';
dotenv.config();

// Configuration par dÃ©faut (fallback)
const defaultConfig = {
  port: process.env.PORT || 4002,
  serviceName: process.env.SERVICE_NAME || 'notification-service',
  database: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    name: process.env.DB_NAME || 'notification'
  },
  rabbitmq: {
    url: process.env.RABBITMQ_URL || 'amqp://localhost:5672',
    exchange: process.env.RABBITMQ_EXCHANGE || 'user.events',
    queue: process.env.RABBITMQ_QUEUE || 'queue.user.created'
  },
  email: {
    user: process.env.EMAIL_USER || '',
    pass: process.env.EMAIL_PASS || ''
  },
  eureka: {
    host: process.env.EUREKA_HOST || 'localhost',
    port: process.env.EUREKA_PORT || 8761
  }
};

let currentConfig = { ...defaultConfig };

export async function initializeConfig() {
  try {
    console.log('ðŸ“¡ Fetching configuration from Config Service...');
    
    // Essayer de rÃ©cupÃ©rer la configuration du service Spring Boot
    const remoteConfig = await fetchConfigFromSpringConfig();
    
    // Fusionner avec la configuration par dÃ©faut
    currentConfig = { ...defaultConfig, ...remoteConfig };
    
    console.log('âœ… Configuration loaded successfully');
    return currentConfig;
    
  } catch (error) {
    console.log('âš ï¸ Using default configuration (Config Service unavailable)');
    return currentConfig;
  }
}

async function fetchConfigFromSpringConfig() {
  const configServiceUrl = process.env.CONFIG_SERVICE_URL || 'http://localhost:8888';
  const serviceName = process.env.SERVICE_NAME || 'notification-service';
  
  try {
    const response = await fetch(`${configServiceUrl}/${serviceName}/default`);
    const configData = await response.json();
    
    // Convertir le format Spring Boot en notre format
    return extractConfigFromSpringResponse(configData);
    
  } catch (error) {
    throw new Error(`Config Service unavailable: ${error.message}`);
  }
}

function extractConfigFromSpringResponse(springConfig) {
  const config = {};
  
  if (springConfig.propertySources) {
    springConfig.propertySources.forEach(source => {
      Object.assign(config, mapSpringProperties(source.source));
    });
  }
  
  return config;
}

function mapSpringProperties(properties) {
  return {
    port: properties['server.port'],
    serviceName: properties['spring.application.name'],
    database: {
      host: extractHostFromUrl(properties['spring.datasource.url']),
      user: properties['spring.datasource.username'],
      password: properties['spring.datasource.password'],
      name: extractDbName(properties['spring.datasource.url'])
    },
    rabbitmq: {
      url: `amqp://${properties['spring.rabbitmq.host']}:${properties['spring.rabbitmq.port']}`,
      exchange: properties['notification.rabbitmq.exchange'],
      queue: properties['notification.rabbitmq.queue']
    },
    email: {
      user: properties['spring.mail.username'],
      pass: properties['spring.mail.password']
    },
    eureka: {
      host: extractEurekaHost(properties['eureka.client.serviceUrl.defaultZone']),
      port: extractEurekaPort(properties['eureka.client.serviceUrl.defaultZone'])
    }
  };
}

function extractHostFromUrl(url) {
  const match = url?.match(/:\/\/([^\/:]+)/);
  return match ? match[1] : 'localhost';
}

function extractDbName(url) {
  const match = url?.match(/\/([^\/?]+)(\?|$)/);
  return match ? match[1] : 'notification';
}

function extractEurekaHost(url) {
  const match = url?.match(/https?:\/\/([^:]+)/);
  return match ? match[1] : 'localhost';
}

function extractEurekaPort(url) {
  const match = url?.match(/https?:\/\/[^:]+:(\d+)/);
  return match ? parseInt(match[1]) : 8761;
}

export default currentConfig;